# Assignment 7
1. A widget tree is like a map of all of the widgets. The top widget is the parent and the widgets inside it are children. For example, a Scaffold can have an AppBar and a Column. This tree tells Flutter how to build your screen, one piece inside another.
2. In this project, i use MaterialApp for the main app. I use Scaffold to make the page, AppBar for the top bar, and Text to show words. I use Column and Row to put widgets in a line. I also use GridView to make a grid of buttons. My custom widgets are InfoCard and ItemCard, which use Material for design, Icon for symbols, and InkWell to make them tappable.
3. The MaterialApp widget is the boss of the whole app. It is to give your app a style (Material Design), a theme (like colors), and to help move between pages. It is the root because it holds everything, every other page or widget lives inside MaterialApp.
4. A StatelessWidget is simple. It does not change after we build it. A StatefulWidget can change. It remembers information and can look different later.
5. A BuildContext is like an address. It tells a widget its location in the widget tree. It is important because widgets use their address to find other widgets. In the build method, i use context to get things from parents, like Theme.of(context) to get a color, or ScaffoldMessenger.of(context) to show a SnackBar.
6. "Hot reload" is very fast. It updates your code, but it keeps your app's data. It is good for fixing the look of your app. "Hot restart" is slower. It throws away all the app's data and starts the app new. You use hot restart when hot reload is not enough, or your app's data is broken.

# Assignment 8
1. I use Navigator.push() to open a new screen on top of the current one, like when opening the "Add Product" form. Flutter then automatically adds a "back" arrow to the AppBar to let the user return. I use Navigator.pushReplacement() to go to a new screen and replace the old one, like when tapping "Home" in the drawer.
2. I use Scaffold as the base for every page, including my Home, Add Product, and My Products pages. By adding the AppBar to the top and my LeftDrawer to the drawer property of the Scaffold, every page instantly gets the same top bar and side menu. This makes my app's layout consistent.
3. In my ProductFormPage, I use Padding to add space around each TextFormField so they aren't crowded. I wrap my Column of form fields in a SingleChildScrollView, which is very important. This lets the user scroll when the keyboard opens, preventing the app from crashing or hiding fields.
4. I set my app's color theme one time in main.dart using ThemeData. By setting the primarySwatch to Colors.blue, I made blue the main brand color. This automatically makes my AppBar and the "Save" button blue, giving my app a consistent look without extra code on each page.

# Assignment 9
1. I created the ItemModel class so my app knows exactly what data structure to expect from Django, ensuring fields like price are definitely integers and name is a string. Without this model, Iâ€™d have to manually guess the keys in the JSON map every time, which easily leads to typos and runtime crashes.
2. While the standard http package is fine for basic calls, it doesn't remember my session data between requests. I used CookieRequest because it automatically stores the login cookie from Django, allowing me to stay authenticated while navigating between the "All Products" and "My Products" pages.
3. I used Provider to share a single CookieRequest instance because if I created a new instance on every page, the app would lose my session cookie and "forget" I was logged in. Sharing it ensures the same "cookie jar" is available to the Login page, the Menu, and the Product Forms.
4. I added 10.0.2.2 to ALLOWED_HOSTS so the Android emulator can actually reach my laptop's localhost, and I enabled CORS to allow the web version to talk to the server. If I hadn't configured these, the app would just throw connection refused errors and never load any data.
5. When I fill out the "Add Product" form, Flutter wraps my input into a JSON object and sends it via postJson to my Django backend. Django validates and saves the new soccer gear to the database, then returns a success status that tells my app to display the summary dialog.
6. For login, I send the credentials to Django, which verifies them and returns a session ID cookie that my CookieRequest saves locally. When I click logout, the app sends a request to the server to delete that session, and then clears the local cookie to sign me out completely.
7. I started by updating my Django views to return JSON responses and fixing the create_news_ajax to handle input data correctly. Then, I built the Flutter frontend by setting up Provider for auth, creating the ItemModel, and building the pages to list, filter, and add products with proper validation and navigation.